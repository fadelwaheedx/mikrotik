/**
 * MikrotikLogic.js
 *
 * Contains pure function generators for RouterOS scripts.
 * Supports legacy RouterOS v6 and modern RouterOS v7 syntax.
 */

export const MikrotikLogic = {

    /**
     * Generates PCC (Per Connection Classifier) Load Balancing Script
     *
     * @param {Object} data
     * @param {Array} data.wans - Array of { interface: string, gateway: string, distance: number }
     * @param {string} data.lanInterface - The LAN interface name
     * @param {boolean} data.failover - Whether to include recursive failover
     * @param {string} data.version - 'v6' or 'v7' (default)
     * @returns {string} Generated RouterOS script
     */
    generatePCC: (data) => {
        const { wans, lanInterface, failover, version = 'v7' } = data;

        if (!wans || wans.length < 2) {
            return "# Error: At least 2 WAN interfaces are required for PCC.";
        }

        const timestamp = new Date().toLocaleString();
        let script = `# Generated by X Rebuild on ${timestamp} [RouterOS ${version}]\n`;
        script += `# PCC Load Balancing Script for ${wans.length} WANs\n\n`;

        // 1. IP Addresses & Interfaces
        script += `/ip firewall mangle\n`;

        // 2. Accept LAN traffic to WANs
        wans.forEach((wan, index) => {
             script += `add chain=prerouting dst-address=${wan.gateway} action=accept in-interface=${lanInterface} comment="Accept Traffic to WAN${index + 1}"\n`;
        });
        script += `\n`;

        // 3. Mark Connections (Input)
        wans.forEach((wan, index) => {
            script += `add chain=input in-interface=${wan.interface} action=mark-connection new-connection-mark=WAN${index+1}_CONN passthrough=yes comment="Mark Input WAN${index+1}"\n`;
        });
        script += `\n`;

        // 4. Mark Routing (Output)
        wans.forEach((wan, index) => {
            script += `add chain=output connection-mark=WAN${index+1}_CONN action=mark-routing new-routing-mark=TO_WAN${index+1} passthrough=no comment="Route Output WAN${index+1}"\n`;
        });
        script += `\n`;

        // 5. PCC Rules
        const denominator = wans.length;

        wans.forEach((wan, index) => {
            script += `add chain=prerouting in-interface=${lanInterface} connection-mark=no-mark dst-address-type=!local per-connection-classifier=both-addresses-and-ports:${denominator}/${index} action=mark-connection new-connection-mark=WAN${index+1}_CONN passthrough=yes comment="PCC ${index+1}/${denominator}"\n`;
        });
        script += `\n`;

        // 6. Force Routing based on Connection Marks
        wans.forEach((wan, index) => {
            script += `add chain=prerouting connection-mark=WAN${index+1}_CONN in-interface=${lanInterface} action=mark-routing new-routing-mark=TO_WAN${index+1} passthrough=no comment="Force Route WAN${index+1}"\n`;
        });
        script += `\n`;

        // 7. NAT / Masquerade
        script += `/ip firewall nat\n`;
        wans.forEach((wan, index) => {
            script += `add chain=srcnat out-interface=${wan.interface} action=masquerade comment="Masquerade WAN${index+1}"\n`;
        });
        script += `\n`;

        // 8. Routes (Version Specific Logic)
        if (version === 'v7') {
            // RouterOS v7 uses routing tables, but basic 'routing-mark' usage is often compatible via compatibility layer or 'routing-table' param.
            // Strict v7 prefers: /routing table add name=TO_WAN1; /ip route add routing-table=TO_WAN1
            script += `# RouterOS v7 Routing Tables\n`;
            script += `/routing table\n`;
            wans.forEach((wan, index) => {
                script += `add name=TO_WAN${index+1} fib\n`;
            });
            script += `\n/ip route\n`;
            wans.forEach((wan, index) => {
                script += `add dst-address=0.0.0.0/0 gateway=${wan.gateway} routing-table=TO_WAN${index+1} check-gateway=ping distance=1 comment="Route WAN${index+1}"\n`;
            });
        } else {
            // RouterOS v6
            script += `/ip route\n`;
            wans.forEach((wan, index) => {
                script += `add dst-address=0.0.0.0/0 gateway=${wan.gateway} routing-mark=TO_WAN${index+1} check-gateway=ping distance=1 comment="Route WAN${index+1}"\n`;
            });
        }

        if (!failover) {
            wans.forEach((wan, index) => {
                 script += `add dst-address=0.0.0.0/0 gateway=${wan.gateway} distance=${index + 1} comment="Default Route WAN${index+1}"\n`;
            });
        } else {
            script += `\n# Recursive Failover Logic\n`;
             wans.forEach((wan, index) => {
                script += `add dst-address=8.8.8.8 gateway=${wan.gateway} scope=10 comment="Recursive Check WAN${index+1}"\n`;
            });
        }

        return script;
    },

    /**
     * Generates Netwatch Script (Telegram/Email)
     * @param {Object} data
     * @param {string} data.host - Host to ping
     * @param {string} data.interval - Interval string (e.g. 1m)
     * @param {string} data.type - 'email' or 'telegram'
     * @param {string} data.target - Email address or Telegram Chat ID
     * @param {string} data.token - Telegram Bot Token (optional)
     */
    generateNetwatch: (data) => {
        const { host, interval, type, target, token } = data;
        if (!host || !target) return "# Error: Host and Target required.";

        let script = `/tool netwatch\n`;
        let upScript = "", downScript = "";

        if (type === 'telegram') {
            const msgUp = `"${host} is UP"`;
            const msgDown = `"${host} is DOWN"`;
            const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${target}&text=`;

            upScript = `/tool fetch url="${url}${msgUp}" keep-result=no`;
            downScript = `/tool fetch url="${url}${msgDown}" keep-result=no`;
        } else {
            upScript = `/tool e-mail send to="${target}" subject="${host} UP" body="${host} is back online."`;
            downScript = `/tool e-mail send to="${target}" subject="${host} DOWN" body="${host} is offline."`;
        }

        script += `add host=${host} interval=${interval} up-script={${upScript}} down-script={${downScript}} comment="Netwatch ${host}"\n`;
        return script;
    },

    /**
     * Generates Port Knocking Script
     * @param {Object} data
     * @param {string} data.port1 - Knock 1
     * @param {string} data.port2 - Knock 2
     * @param {string} data.securePort - Target port to open (e.g., 8291)
     */
    generatePortKnocking: (data) => {
        const { port1, port2, securePort } = data;
        let script = `/ip firewall filter\n`;

        script += `add chain=input protocol=tcp dst-port=${port1} action=add-src-to-address-list address-list=knock_stage_1 address-list-timeout=1m comment="Knock 1"\n`;
        script += `add chain=input protocol=tcp dst-port=${port2} src-address-list=knock_stage_1 action=add-src-to-address-list address-list=knock_secure address-list-timeout=1h comment="Knock 2"\n`;
        script += `add chain=input protocol=tcp dst-port=${securePort} src-address-list=knock_secure action=accept comment="Accept Secure Access"\n`;
        script += `add chain=input protocol=tcp dst-port=${securePort} action=drop comment="Drop others"\n`;

        return script;
    },

    /**
     * Generates RAW Security Rules (DDoS/Scanner)
     */
    generateRawSecurity: () => {
        let script = `/ip firewall raw\n`;
        script += `add chain=prerouting action=drop src-address-list=blocked_ips comment="Drop Blocked IPs"\n`;
        script += `add chain=prerouting protocol=tcp psd=21,3s,3,1 action=add-src-to-address-list address-list=blocked_ips address-list-timeout=1d comment="Block Port Scanners"\n`;
        script += `add chain=prerouting protocol=tcp tcp-flags=fin,syn action=drop comment="Drop TCP Fin/Syn"\n`;
        script += `add chain=prerouting protocol=tcp tcp-flags=syn,rst action=drop comment="Drop TCP Syn/Rst"\n`;
        return script;
    },

    // ... (Existing Functions: generateSimpleQueue, generateVPN, etc. kept below)

    generateSimpleQueue: (data) => {
        const { target, maxLimit, burstLimit, timeLimit } = data;
        if (!target || !maxLimit) return "# Error: Target and Max Limit are required.";
        const timestamp = new Date().toLocaleString();
        let script = `# Generated by X Rebuild on ${timestamp}\n`;
        script += `/queue simple\n`;
        let command = `add name="Queue-${target}" target=${target} max-limit=${maxLimit}`;
        if (burstLimit) command += ` burst-limit=${burstLimit}`;
        if (timeLimit) command += ` time=${timeLimit}`;
        script += command + ` comment="Generated Queue"\n`;
        return script;
    },

    generateGameRouting: (data) => {
        const { game, gateway, version = 'v7' } = data;
        if (!game || !gateway) return "# Error: Game and Gateway are required.";
        const timestamp = new Date().toLocaleString();
        let script = `# Generated by X Rebuild on ${timestamp} [RouterOS ${version}]\n`;
        script += `/ip firewall mangle\n`;

        const protoLoop = (proto) => {
            if (game.ports[proto]) {
                game.ports[proto].forEach((port, i) => {
                    script += `add chain=prerouting protocol=${proto} dst-port=${port} action=mark-connection new-connection-mark=${game.id}_conn passthrough=yes comment="${game.name} ${proto} ${i+1}"\n`;
                });
            }
        };
        protoLoop('tcp');
        protoLoop('udp');

        script += `add chain=prerouting connection-mark=${game.id}_conn action=mark-routing new-routing-mark=to_${game.id} passthrough=no comment="Route ${game.name}"\n\n`;

        if (version === 'v7') {
             script += `/routing table add name=to_${game.id} fib\n`;
             script += `/ip route add dst-address=0.0.0.0/0 gateway=${gateway} routing-table=to_${game.id} comment="Route ${game.name}"\n`;
        } else {
             script += `/ip route add dst-address=0.0.0.0/0 gateway=${gateway} routing-mark=to_${game.id} comment="Route ${game.name}"\n`;
        }
        return script;
    },

    generateVPN: (type, data) => {
        const timestamp = new Date().toLocaleString();
        let script = `# Generated by X Rebuild on ${timestamp}\n# VPN: ${type.toUpperCase()}\n\n`;
        const { poolName, poolStart, poolEnd, dns1, dns2, secret, profileName } = data;
        script += `/ip pool add name="${poolName}" ranges=${poolStart}-${poolEnd}\n`;
        let profileCmd = `/ppp profile add name="${profileName}" local-address="${poolStart}" remote-address="${poolName}"`;
        if (dns1) profileCmd += ` dns-server=${dns1},${dns2||''}`;
        script += profileCmd + "\n";
        script += `/ppp secret add name="vpnuser" password="${secret}" profile="${profileName}" service=${type}\n`;

        if (type === 'pptp') script += `/interface pptp-server server set enabled=yes default-profile="${profileName}"\n`;
        if (type === 'l2tp') script += `/interface l2tp-server server set enabled=yes use-ipsec=yes ipsec-secret="${secret}" default-profile="${profileName}"\n`;
        if (type === 'ovpn') script += `/interface ovpn-server server set enabled=yes default-profile="${profileName}" certificate=server\n`;

        return script;
    },

    generateContentRouting: (apps, listName) => {
         if (!apps || !listName) return "# Error";
         let script = `/ip firewall address-list\n`;
         const domains = {
            youtube: ['youtube.com', 'googlevideo.com'],
            netflix: ['netflix.com', 'nflxvideo.net'],
            tiktok: ['tiktok.com', 'tiktokv.com'],
            facebook: ['facebook.com', 'fbcdn.net']
         };
         apps.forEach(app => {
             if (domains[app]) {
                 domains[app].forEach(d => script += `add list=${listName} address=${d} comment="${app}"\n`);
             }
         });
         return script;
    }
};
