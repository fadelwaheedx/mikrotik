/**
 * MikrotikLogic.js
 *
 * Contains pure function generators for RouterOS scripts.
 * This file minimizes server round-trips for simple text generation.
 */

export const MikrotikLogic = {

    /**
     * Generates PCC (Per Connection Classifier) Load Balancing Script
     *
     * @param {Object} data
     * @param {Array} data.wans - Array of { interface: string, gateway: string, distance: number }
     * @param {string} data.lanInterface - The LAN interface name
     * @param {boolean} data.failover - Whether to include recursive failover
     * @returns {string} Generated RouterOS script
     */
    generatePCC: (data) => {
        const { wans, lanInterface, failover } = data;

        if (!wans || wans.length < 2) {
            return "# Error: At least 2 WAN interfaces are required for PCC.";
        }

        const timestamp = new Date().toLocaleString();
        let script = `# Generated by X Rebuild on ${timestamp}\n`;
        script += `# PCC Load Balancing Script for ${wans.length} WANs\n\n`;

        // 1. IP Addresses & Interfaces (Assumed already configured, but adding comments)
        script += `/ip firewall mangle\n`;

        // 2. Accept LAN traffic to WANs (avoid loops)
        wans.forEach((wan, index) => {
             script += `add chain=prerouting dst-address=${wan.gateway} action=accept in-interface=${lanInterface} comment="Accept Traffic to WAN${index + 1}"\n`;
        });
        script += `\n`;

        // 3. Mark Connections (Input)
        wans.forEach((wan, index) => {
            script += `add chain=input in-interface=${wan.interface} action=mark-connection new-connection-mark=WAN${index+1}_CONN passthrough=yes comment="Mark Input WAN${index+1}"\n`;
        });
        script += `\n`;

        // 4. Mark Routing (Output)
        wans.forEach((wan, index) => {
            script += `add chain=output connection-mark=WAN${index+1}_CONN action=mark-routing new-routing-mark=TO_WAN${index+1} passthrough=no comment="Route Output WAN${index+1}"\n`;
        });
        script += `\n`;

        // 5. PCC Rules (The Core Logic)
        // Denominator is the number of WANs
        const denominator = wans.length;

        wans.forEach((wan, index) => {
            // remainder is the index (0, 1, 2...)
            script += `add chain=prerouting in-interface=${lanInterface} connection-mark=no-mark dst-address-type=!local per-connection-classifier=both-addresses-and-ports:${denominator}/${index} action=mark-connection new-connection-mark=WAN${index+1}_CONN passthrough=yes comment="PCC ${index+1}/${denominator}"\n`;
        });
        script += `\n`;

        // 6. Force Routing based on Connection Marks
        wans.forEach((wan, index) => {
            script += `add chain=prerouting connection-mark=WAN${index+1}_CONN in-interface=${lanInterface} action=mark-routing new-routing-mark=TO_WAN${index+1} passthrough=no comment="Force Route WAN${index+1}"\n`;
        });
        script += `\n`;

        // 7. NAT / Masquerade
        script += `/ip firewall nat\n`;
        wans.forEach((wan, index) => {
            script += `add chain=srcnat out-interface=${wan.interface} action=masquerade comment="Masquerade WAN${index+1}"\n`;
        });
        script += `\n`;

        // 8. Routes
        script += `/ip route\n`;
        wans.forEach((wan, index) => {
            script += `add dst-address=0.0.0.0/0 gateway=${wan.gateway} routing-mark=TO_WAN${index+1} check-gateway=ping distance=1 comment="Route WAN${index+1}"\n`;
        });

        // Default Routes (ECMP or Failover fallback)
        if (!failover) {
            // Simple routes with distance
            wans.forEach((wan, index) => {
                 script += `add dst-address=0.0.0.0/0 gateway=${wan.gateway} distance=${index + 1} comment="Default Route WAN${index+1}"\n`;
            });
        } else {
            script += `\n# Recursive Failover Logic (8.8.8.8 / 1.1.1.1)\n`;
            // This is a simplified placeholder for recursive failover logic
            // In a real app, we'd generate specific scope/target-scope rules
             wans.forEach((wan, index) => {
                script += `add dst-address=8.8.8.8 gateway=${wan.gateway} scope=10 comment="Recursive Check WAN${index+1}"\n`;
            });
        }

        return script;
    }
};
